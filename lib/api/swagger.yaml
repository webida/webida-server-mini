#
# Webida Service Api specifiaion
#

# Common api desingn rules
#  1) Any, and only 'reusable' schemas should be placed in #/parameters, #/definitions
#  2) Do not use multiple tags in a single operaion to reduce client code size
#  3) Any path parameter which contains'/' should be placed at the end of path params
#  4) Prefer /some-name-plural/{id} form (except wfs) and don't mix sigular form.
#  5) All response should be an object or file. No Plain Text!
#  6) Keep common/starndard http status code semantic, as possible as you can.
#  7) Keep spec minimal. Don't make too complex schemas with strict format and patterns.
#  8) Do not forget about non-js implementations.
#  9) Do not split this document into pieces, for none of standard swagger tools supoorts
#     multi-docs spec yet.

# notes for swaggerize-routes
# 1) 1 x-handler impl module for 1-endpoint path, not for every single method
# 2) operation id should be kept in implementation method/function name
#     if possible, provide module (class) name same to tag

swagger: '2.0'

info:
  version: "0.1"
  title: Webida Service API
  description: Webida Service API specfication
  license:
    name: Apache 2.0
    url: http://www.apache.org/licenses/LICENSE-2.0.html


# Should not include host / schemes in this spec, for server/client implementation
#  wants to override the values always, anyway.

basePath: /api

produces:
  - application/json
  - application/octet-stream

consumes:
  - application/json

paths:

  /auth/login:
    x-handler: handlers/auth/login.js
    post:
      tags: ["auth"]
      description: |
        A 'VERY' basic authentication, required to use webida-simple-auth security scheme.

        Service / Product implementations who need better security, should override this operation
        or add their own login api or some other specs like OAuth2. Simple auth is not suitable
        for large-sacle, multi-tennant service.

        Generated accss token inherits all restriction from master token. In normal login,
        unrestricted access token will be granted with reasonably short expiration time.
        Every client should respawn another access token with issueToken API before current
        access token expires.

      operationId: login
      parameters:
        - name: body
          in: body
          required: true
          schema:
            $ref: "#/definitions/Credential"
      responses:
        "200":
          description: login success
          schema:
            $ref: "#/definitions/Token"
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

  /auth/info:
    x-handler: handlers/auth/info.js
    get:
      tags: ["auth"]
      description: |
        Gets user information of that can be identified with current access token. Implementations
        should provide a more restful api based on domain data model. Don't override this operation
        for multi-user system.
      operationId: getInfo
      security:
        - webida-simple-auth: []
      responses:
        "200":
          description: user information
          schema:
            $ref: "#/definitions/User"
        "401":
          description: auth failed
          schema:
            $ref: "#/definitions/RestError"
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

  /auth/token:
    post:
      tags: ["auth"]
      description: |
        Creates new token from current access token, inheriting workspace id & session id
        Duration of generated token is not (and should be) parameterizable.
      operationId: issueToken
      security:
        - webida-simple-auth: []
      parameters:
        - name: type
          in: query
          required: true
          type: string
          enum: ['MASTER', 'ACCESS']
        - name: workspaceId
          in: query
          required: false
          type: string
          description: mandatory to issue a MASTER type token
      responses:
        "200":
          description: new token generated
          schema:
            $ref: "#/definitions/Token"
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

  #
  # wfs paths starts with /wfs/{wfsId}
  #  /file/{wfsPath} file CRUD C,U is PUT, not POST
  #    GET - read file
  #    PUT - write file
  #    POST?{src} - rename to (supports dir too)
  #  /dir/{wfsPath} directory CRUD
  #    GET - list (read) dir
  #    PUT - create (will be expanded to import, later)
  #    POST?{src} - move to dir (supports file too)
  #  /any/{wfsPath}
  #    GET - stats
  #    PUT?{src} - copy
  #    POST?{src}&{op} - move or rename by op
  #    DELETE - delete
  #  /ops/mstats?{wfsPathList} bulk stats (GET)
  #  /ops/search/{wfsPath} for search (GET) and replace (POST)
  #  /ops/replace?/{wfsPath} for search (GET) and replace (POST)
  #
  #  we can't use /wfs/{wfsId}/{wfsPath} form because swagger does not support 'one-of' in json schema and
  #  nor path spec with query parameter. For example, a GET request, having 3 semantics - stat/list/read.
  #  So, reading from /{wfsId}/{wfsPath} requires 3 endpoint paths.
  #

  /wfs/{wfsId}/file/{wfsPath}:
    x-handler: handlers/wfs/file.js

    # readFile.
    get:
      tags: ["wfs"]
      description: read file data on path
      operationId: readFile
      security:
        - webida-simple-auth: []
      parameters:
        - $ref : "#/parameters/wfsId"
        - $ref : "#/parameters/wfsPath"
      responses:
        "200":
          description:  file contents. content-type is app.../octet-stream or follows file name extensions
          schema:
            type: file
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

    # writeFile
    put:
      tags: ["wfs"]
      description: create / update file with body data
      operationId: writeFile
      consumes:
        - multipart/form-data
      security:
        - webida-simple-auth: []
      parameters:
        - $ref : "#/parameters/wfsId"
        - $ref : "#/parameters/wfsPath"
        - $ref : "#/parameters/ensure"
        - name : data
          in : formData
          required : true
          description : file contents to write.
          type : file
      responses:
        "200":
          description: OK
          schema:
            type: file
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

    # rename
    post:
      tags: ["wfs"]
      description: Rename a file or directory to. This api does not remove an existing one.
      operationId: rename
      security:
        - webida-simple-auth: []
      parameters:
        - $ref : "#/parameters/wfsId"
        - $ref : "#/parameters/wfsPath"
        - $ref : "#/parameters/srcPath"
        - $ref : "#/parameters/ensure"
      responses:
        "200":
          description: OK
          schema:
            type: file
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

  /wfs/{wfsId}/dir/{wfsPath}:
    x-handler: handlers/wfs/dir.js
    # dirTree
    get:
      tags: ["wfs"]
      description: |
        returns a directory tree of given path, for listing dir and managing file system
      operationId: dirTree
      security:
        - webida-simple-auth: []
      parameters:
        - $ref : "#/parameters/wfsId"
        - $ref : "#/parameters/wfsPath"
        - name : maxDepth
          description : Maximum depth of tree. Set -1 to build a full tree, 0 to stat, 1 to plain list.
          in : query
          type : integer
          required: true
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/DirEntry'
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

    # createDir
    put:
      tags: ["wfs"]
      description: create a directory at the path. will return error when wfsPath exists and not empty
      operationId: createDir
      security:
        - webida-simple-auth: []
      parameters:
        - $ref : "#/parameters/wfsId"
        - $ref : "#/parameters/wfsPath"
        - $ref : "#/parameters/ensure"
      responses:
        "200":
          description: OK
          schema:
            $ref: "#/definitions/RestOK"
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

    # move
    post:
      tags: ["wfs"]
      description: move file or directory to given path. works like mv command
      operationId: move
      security:
        - webida-simple-auth: []
      parameters:
        - $ref : "#/parameters/wfsId"
        - $ref : "#/parameters/wfsPath"
        - $ref : "#/parameters/srcPath"
        - $ref : "#/parameters/removeExisting"
      responses:
        "200":
          description: OK
          schema:
            $ref: "#/definitions/RestOK"
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

  /wfs/{wfsId}/any/{wfsPath}:
    x-handler: handlers/wfs/any.js
    # stat
    get:
      tags: ["wfs"]
      description: get stats of given path. (stat returns 'stats' object in node and POSIX)
      operationId: stat
      security:
        - webida-simple-auth: []
      parameters:
        - $ref : "#/parameters/wfsId"
        - $ref : "#/parameters/wfsPath"
        - name : ignoreError
          in : query
          required : false
          description : flag to ignore stat errors to check existence only
          type : boolean
          default: false
      responses:
        "200":
          description: stats object
          schema:
            $ref: "#/definitions/Stats"
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

    # copy
    put:
      tags: ["wfs"]
      description: |
        Copy to given path. works like cp -r command, with some funny options
        Copying a dir on to existing file will return error if removeExisting is false
        Copying from sockets, fifo, .. and any other type of file system object is not supported.
      operationId: copy
      security:
        - webida-simple-auth: []
      parameters:
        - $ref : "#/parameters/wfsId"
        - $ref : "#/parameters/wfsPath"
        - $ref : "#/parameters/srcPath"
        - $ref : "#/parameters/removeExisting"
        - name: followSymbolicLinks
          in: query
          description: dereference symlinks or not
          required: false
          type: boolean
          default: false
        - name: noPreserveTimestamps
          in: query
          description: to change default behavior, keep mtime/atime of source files in destination
          required: false
          type: boolean
          default: false
        - name: filterPattern
          in: query
          description: execute copy if source matches to this regex pattern.
          required: false
          type: string
      responses:
        "200":
          description: OK
          schema:
            $ref: "#/definitions/RestOK"
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

    # remove / delete
    delete:
      tags: ["wfs"]
      description: delete file or directory
      operationId: remove
      security:
        - webida-simple-auth: []
      parameters:
        - $ref : "#/parameters/wfsId"
        - $ref : "#/parameters/wfsPath"
        - $ref : "#/parameters/recursive"
      responses:
        "200":
          description: OK
          schema:
            $ref: "#/definitions/RestOK"
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

    # currently, no POST for any type (will be defined later)

  # search
  /wfs/{wfsId}/ops/search/{wfsPath}:
    x-handler: handlers/wfs/search.js
    get:
      tags: ["ops"]
      description: search files in some path, with given pattern
      operationId: search
      security:
        - webida-simple-auth: []
      parameters:
        - $ref: "#/parameters/wfsId"
        - $ref: "#/parameters/wfsPath"
        - $ref: "#/parameters/pattern"
        - $ref: "#/parameters/ignoreCase"
        - $ref: "#/parameters/wholeWord"
      responses:
        "200":
          description: stats list (define SearchResult first)
          schema:
            type: object
            additionalProperties:
              $ref: '#/definitions/Match'
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

  # replace
  /wfs/{wfsId}/ops/replace:
    x-handler: handlers/wfs/replace.js
    post:
      description: replace file contents with regex matching
      operationId: replace
      security:
        - webida-simple-auth: []
      parameters:
        - $ref: "#/parameters/wfsId"
        - $ref: "#/parameters/wfsPathList"
        - $ref: "#/parameters/pattern"
        - name: replaceTo
          in: query
          description: string to replace with
          type: string
          required: true
        - $ref: "#/parameters/ignoreCase"
        - $ref: "#/parameters/wholeWord"
      responses:
        "200":
          description: done
          schema:
            $ref: "#/definitions/RestOK"
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

  #
  # mstat, mcopy and mmove operations are reserved for next release (1.1)
  # /wfs/{wfsId}/ops/mcopy/{wfsPath}: PUT
  # /wfs/{wfsId}/ops/mmove/{wfsPath}: POST
  # /wfs/{wfsId}/ops/mstats:
  #   get:
  #     tags: ["ops"]
  #     description: get stats of given path.
  #     operationId: mstats
  #     security:
  #       - webida-simple-auth: []
  #     parameters:
  #       - $ref : "#/parameters/wfsId"
  #       - $ref : "#/parameters/wfsPathList"
  #     responses:
  #       "200":
  #         description: stats list
  #         schema:
  #           type: array
  #           items:
  #             $ref: "#/definitions/Stats"
  #     default:
  #       description: Error
  #       schema:
  #         $ref: "#/definitions/RestError"

  /workspaces:
    x-handler: handlers/workspace/all.js

    # getAllWorkspaces
    get:
      tags: ["workspace"]
      description: |
        get all registerd (non-disposable) workspaces in the server. since webida is not designed to
        host so many workspaces, there's no good 'find' or 'query' API. Service/product implementations
        may create a better opeation.
      operationId: getAllWorkspaces
      security:
        - webida-simple-auth: []
      parameters:
        - name : disposable
          in : query
          required : false
          description: include disposable workspaces in response
          type : boolean
          default : false
      responses:
        "200":
          description: array of all workspaces
          schema:
            type: array
            items:
              $ref: "#/definitions/Workspace"
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

    # createWorkspace
    post:
      tags: ["workspace"]
      description: create a new workspace at given path
      operationId: createWorkspace
      security:
        - webida-simple-auth: []
      parameters:
        - name : workspacePath
          in : query
          required : true
          description : a real/local path of the system
          type : string
          allowEmptyValue: false
      responses:
        "200":
          description: newly created workspace
          schema:
            $ref: "#/definitions/Workspace"
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

  /workspaces/{workspaceId}:
    x-handler: handlers/workspace/workspace.js

    # getWorkspace
    get:
      tags: ["workspace"]
      description: get all workspaces registerd (non-disposable) in the server
      operationId: getWorkspace
      security:
        - webida-simple-auth: []
      parameters:
        - $ref : "#/parameters/workspaceId"
      responses:
        "200":
          description: the workspace
          schema:
            $ref: "#/definitions/Workspace"
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

    # update workspace
    put:
      tags: ["workspace"]
      description: update workspace information. some properties will not be updated by this api.
      operationId: updateWorkspace
      security:
        - webida-simple-auth: []
      parameters:
        - $ref : "#/parameters/workspaceId"
      responses:
        "200":
          description: updated Workspace object
          schema:
            $ref: "#/definitions/Workspace"
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

    # delete workspace
    delete:
      tags: ["workspace"]
      description: remove a workspace. all sessions on this workspace will be closed.
      operationId: removeWorkspace
      security:
        - webida-simple-auth: []
      parameters:
        - $ref : "#/parameters/workspaceId"
        - name: wait
          in: query
          description: |
            Time in seconds to wait for all sessions save & close their data.
            zero or negative value will close the sessions immediatlely.
          type: integer
          required: false
          default: 0
      responses:
        "200":
          description: removed Workspace object
          schema:
            $ref: "#/definitions/Workspace"
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

  /workspaces/{workspaceId}/exec:
    x-handler: handlers/workspace/exec.js

    #exec
    post:
      tags: ["workspace"]
      description: execute a shell command
      operationId: exec
      security:
        - webida-simple-auth: []
      parameters:
        - $ref: "#/parameters/workspaceId"
        - name: async
          in: query
          description: |
            Spawn a child process for given command and returns a dummy response immediatlely,
            Actual output (stream of message) will be pasted to web socket channel of current session.
          type: boolean
          required: false
          default: false
        - name: body
          in: body
          required: true
          schema:
            $ref: "#/definitions/ExecRequest"
      responses:
        "200":
          description: execution result with all captured standard ouput and error
          schema:
            $ref: '#/definitions/ExecResponse'
        "201":
          description: dummy response for async execution
          schema:
            $ref: '#/definitions/ExecResponse'
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

    #cancel
    delete:
      tags: ["workspace"]
      description: cancels an execution, if possible. Killing process may not be graceful.
      operationId: cancel
      security:
        - webida-simple-auth: []
      parameters:
        - $ref: "#/parameters/workspaceId"
        - name: execId
          in: query
          description: |
            the execId property in ExecRequest
          type: string
          required: true
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/RestOK'
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

  # metadata save/load APIs are coming soon...


  /sessions:
    x-handler: handlers/session/all.js
    get:
      tags: ["session"]
      description: get all / some webida sessions established to server
      operationId: getSessions
      security:
        - webida-simple-auth: []
      parameters:
        - name : workspaceId
          in : query
          required : false
          description: only include sessions working on some given workspace
          type : string
      responses:
        "200":
          description: array of sessions
          schema:
            type: array
            items:
              $ref: "#/definitions/Session"
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

    # We dont define method POST here, for all sessions are made from web socket connections.
    # And, we should separate ws connection end-point from API, for some servers will
    # not host web socket in api implementation


  /sessions/{sessionId}:
    x-handler: handlers/session/session.js
    get:
      tags: ["session"]
      description: get a session object by id
      operationId: getSession
      security:
        - webida-simple-auth: []
      parameters:
        - $ref: "#/parameters/sessionId"
      responses:
        "200":
          description: session
          schema:
            $ref: "#/definitions/Session"
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"

    delete:
      tags: ["session"]
      description: close session with timeout
      operationId: deleteSession
      security:
        - webida-simple-auth: []
      parameters:
        - $ref: "#/parameters/sessionId"
        - name: closeAfter
          in: query
          type: integer
          description: waiting time before actual closing, to let client save files and prevent reconnect
          required: true
      responses:
        "200":
          description: array of sessions
          schema:
            $ref: "#/definitions/RestOK"
        default:
          description: Error
          schema:
            $ref: "#/definitions/RestError"


securityDefinitions:
  webida-simple-auth:
    type: apiKey
    name: Authorization
    in: header
    x-authorize: webida-simple-auth.js

parameters:
  wfsId:
    name: wfsId
    in: path
    description: webida file system id (same to workspace id) to access.
    required: true
    type: string

  wfsPath:
    name: wfsPath
    in: path
    description: |
      webida file system path to access. without heading /. should be placed at the end of path arguments
    required: true
    type: string
    pattern: .*

  srcPath:
    name: srcPath
    in: query
    description: source data path of some operations, with have heading /
    required: true
    type: string

  wfsPathList:
    name: wfsPathList
    in: query
    description: array of wfsPath, with heading /  (collection format may be changed by implementation)
    required: true
    type: array
    items:
      type: string
    collectionFormat: multi

  ensure:
    name : ensure
    in : query
    required : false
    description : flag to create all parent directories to create file or dir, like mkdir -p
    type : boolean
    default: false

  recursive:
    name : recursive
    in : query
    required : false
    description : flag to set copy with
    type : boolean
    default: false

  removeExisting:
    name: removeExisting
    in: query
    description: remove any existing file/dir before writing.
    required: false
    type: boolean
    default: false

  pattern:
    name: pattern
    in: query
    description: regex pattern to match
    type: string
    required: true

  ignoreCase:
    name: ignoreCase
    in: query
    description: regex matching option to ignore case
    type: boolean
    required: false
    default: false

  wholeWord:
    name: wholeWord
    in: query
    description: regex matching option to match whole word
    type: boolean
    required: false
    default: false

  workspaceId:
    name: workspaceId
    in: path
    description: webida workspace id (usually same to file system id, wfsId)
    required: true
    type: string

  sessionId:
    name: sessionId
    in: path
    description: webida session id (usually different from socket id from sock.io)
    required: true
    type: string


definitions:

  RestOK:
    type: object
    properties:
      message:
        type: string

  RestError:
    type: object
    description:  Contains status text, not status code.
    # It's bound to status code, but not always. For Example,
    #   some 409 error will have code 'Invalid Argument Error', not 'Conflict Error'. Client should read
    #     message property to know what happened and why, exactly.
    properties:
      code:
        type: string
      message:
        type: string
    required:
      - message

  Token:
    type: object
    description: a json webtoken and accessible data
    properties:
      text:
        type: string
        description: actual token text that should be shipped in header or query
      tokenType:
        type: string
        enum: ['MASTER', 'ACCESS', 'ADMIN']
        description: |
          MASTER : used to create an access token from clients, without login credential
          ACCESS : protects api access. should be unique for each ide session
          ADMIN  : unrestriced access token for hub/admin service who controls server.
                   there's no way to create admin token with API.

          Note that here's no REFRESH token, nor LOGIN token. The login api will create
          unrestricted access token & master token pair. Desktop app has a side-way to
          create an unrestricted master token before starting IDE instances.
      expiresAt:
        type: string
        format: date-time
      issuedAt:
        type: string
        format: date-time
      sessionId:
        type: string
        description: mandatory for ACCESS token, identifying client instance
      workspaceId:
        type: string
        description: If truthy, access rights are restricted to specified workspace only.
    required:
      - text
      - tokenType
      - expiresAt
      - issuedAt

  Credential:
    type: object
    description: user credential to login. Use https to protect credential.
    properties:
      loginId:
        type: string
      loginPassword:
        type: string
      masterToken:
        type: string
        description: |
          a master token is issued when user wants to access webida api without id/password
          from remote or local desktop app. When masterToken is set, client should put some
          bogus id/password, non-empty. (The values can be used to identify client type)
    required:
      - loginId
      - loginPassword

  User:
    type: object
    description: |
        Any services/products should define some admin apis to manage users in the system and
        expose what should be exposed to client app. So, no properties are mandatory.
        Currently, properties are defined for compatiblity with legacy clients.
    properties:
      id:
        type: string
        description: unique id per user (email is also unique)
      email:
        type: string
      name:
        type: string

  Stats:
    type: object
    description: simplified/augmented fs.Stats class - see node.js doc for all properties
    required:
      - type
    properties:
      type:
        type: string
        enum: ['DUMMY', 'FILE', 'DIRECTORY', 'BLOCK_DEVICE', 'CHARACTER_DEVICE', 'LINK', 'FIFO', 'SOCKET']
      birthtime:
        type: string
        format: date-time
      mtime:
        type: string
        format: date-time
      mode:
        type: string
      size:
        type: integer
      nlink:
        type: integer
      error:
        $ref: "#/definitions/RestError"

  DirEntry:
    type: object
    description: a directory entry (file or directory) with children that represents a (sub) tree
    required:
      - name
      - stats
      - children
    properties:
      name:
        type: string
      stats:
        $ref: "#/definitions/Stats"
      children:
        type: array
        items:
          $ref: "#/definitions/DirEntry"

  Match:
    type: object
    description: search result for a file
    required:
      - line
      - text
    properties:
      line:
        type: integer
      text:
        type: string

  Workspace:
    type: object
    description: A workspace in server
    properties:
      id:
        description: the id of a workspace. usually same to file system id
        type: string
      name:
        description: display text of this workspace for UI
        type: string
      description:
        description: human readable description on this workspace
        type: string
      createdAt:
        description: the time when this workspace is created (registered from local file system)
        type: string
        format: date-time
      accessedAt:
        description: the time when the last session on this workspace was made
        type: string
        format: date-time
      workspacePath:
        description: absolute path of this workspace in server. (not always available)
        type: string
    required:
      - id
      - name
      - description
      - createdAt
      - accessedAt

  Session:
    type: object
    description: an application session per ide instance. bound to access token
    properties:
      id:
        description: the id of a session. usually same to socket id.
        type: string
      name:
        description: human readable name, usually derived from workspace name.
        type: string
      state:
        description: |
          state of this session
          NORMAL = connected, normally working
          LOSING = disconnected, waiting reconnection. still accessible with api
          CLOSING = socket connection will close connection by server (clinet will be notified)

          there's no 'CLOSED' / 'LOST' state, for server will remove session object in registry
          when the server closes connection or stops waiting for reconnection for timeout.
        type: string
        enum:
          - NORMAL
          - LOSING
          - CLOSING
      workspaceId:
        description: the id of workspace that this sessions is working on.
        type: string
      clientAddress:
        description: the peer address of session connection. not always
        type: string
      connectedAt:
        description: the time when socket connection is established
        type: string
        format: date-time
      disconnectedAt:
        description: the time when socket is closed.
        type: string
        format: date-time
      willCloseAt:
        description: when state becomes CLOSING, actual closing time will be updated by server.
        type: string
        format: date-time
      willLoseAt:
        description: when state becomes LOSING, server will not wait for reconnection after this time.
        type: string
        format: date-time
    required:
      - id
      - name
      - state
      - clientAddress
      - connectedAt
      - disconnectedAt

  ExecRequest:
    type: object
    description: |
      execution request, simlilar to node.js spawn(). see node.js documentation for
      details of each properties. some properties are not configurable for portability
         - encoding : fixed to utf-8
         - shell : fixed to system default. Using shell variables in command may not work.
         - killSignal : fixed to SIGTERM. If process does not die, server can send SIGKILL or
                        invoke taskkill to ensure chlid process is killed.
         - uid & gid : will not be set
         - stdio : all streams are handled by server. no options are avaliable to client.
         - shell : always false.
         - detached : always false
    required:
      - id
      - command
      - args
    properties:
      id:
        description: unique identifier of execution, to demux response stream or cancel request
        type: string
      command:
        description: |
          command to run. should not contain any arguments, pipes, redirections
        type: string
      args:
        description: the arguments array
        type: array
        items:
          type: string
      cwd:
        description: |
          Current working directory of child process, relative to workspace root. If abscent,
          CWD will be the workspace root directory. Does not accept any evaluatable form like
          $HOME, %USERPROFILE%. If absolute, heading / will be discarded. should be unixified.
        type: string
      input:
        description: |
          input string for child process. if falsy in async execution, async input messages
          will be pasted into the child's stdin. since we don't use tty, it's recommended
          to use input string anyway.
        type: string
      timeout:
        description: |
          The value which In 'milliseconds' the maximum amount of time the child is allowed
          to run. (not idle time of stdout / stderr stream) if undefined, server will not
          kill the child process until receiving cancel request  if it doesn't exit by self.
        type: integer

  ExecResponse:
    type: object
    description: execution response
    properties:
      exitCode:
        description: exit code of child process. always 0 for async exec
        type: integer
      stdout:
        description: standard out of child process. empty for async exec
        type: string
      stderr:
        description: standard error of child process. empty for async exec
        type: string
    required:
      - exitCode
      - stdout
      - stderr

  # BulkOperationResponse: (pending for next release, 1.1)
  #   type: object
  #   description: |
  #     A map of errors from input list value when some of them failed. Ususally,
  #     If  all of inputs succeeds, then the op. response will have status 200
  #     If  any of inputs succeeds, then the op. response will have status 207
  #     If none of inputs succeeds, then the op. response will have status 207, too.
  #     This object does not contains any entries that is completed without error.
  #     In other words, map contains only errors. When status code is 200, result map will be empty.
  #     So, any 'single' operation contained in bulk operatino should have 200 - RESTOK
  #      for successful result. no other complex data types are allowed.
  #   additionalProperties:
  #     type: object